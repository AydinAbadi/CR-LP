% !TEX root =main.tex

\subsection{Evaluation}\label{full-Evaluation}

In this section, we provide a comparison summary between  SO-PoR and outsourced PoRs  \cite{armknecht2014outsourced,xu2016lightweight,Storage-Time}.   Note, there are two protocols  proposed in  \cite{Storage-Time}; In the following, we only consider the one that supports public verifiability, e.g. basic PoSt.  In our analysis, we consider a generic setting where a client outsources $z$ verifications. We outline the property and cost comparison results in Tables \ref{table::O-PoR-Property} and \ref{table::O-PoR-Cost}, respectively. Also, in our cost analysis, we compare SO-PoR cost with the cost of the most efficient privately verifiable traditional PoR \cite{DBLP:conf/asiacrypt/ShachamW08}, too. A full analysis is provided in Appendix \ref{Full-Evaluation}.

\input{table-PoR-property.tex}


\input{table-PoR-cost.tex}


\noindent\textbf{\textit{Properties}}. Briefly, only SO-PoR offers an explicit solution for real-time detection. Unlike the rest, it also supports efficient fair payment. The authors of \cite{Storage-Time}  briefly suggest that in their  ``basic PoSt''  protocol the verification can be performed by a smart contract, so it can pay the server after approving all proofs, i.e. fair payment. However, this is  only of \emph{theoretical interest}, as in practice its verification algorithm imposes significant computation, communication and financial cost to the smart contract and the user (higher than the costs of strawman solutions discussed in Section \ref{Strawman-Solutions}). Furthermore,  a client in  \cite{xu2016lightweight} has to fully trust the auditor with the correctness of verification, but this assumption is relaxed in   SO-PoR and  \cite{armknecht2014outsourced}, and  if a contract performs the verification in \cite{Storage-Time}.  %Also, the protocol in \cite{armknecht2014outsourced} is the only outsourced PoR secure against a malicious client. 



\noindent\textbf{\textit{Computation Complexity}}.  The verification in SO-PoR is much faster than the other three protocols; firstly, it requires no exponentiations in this phase, whereas \cite{xu2016lightweight,Storage-Time} do require a high number of exponentiations (i.e. $6z$ and $3z$ respectively), and secondly, it requires $\frac{9c+3}{2(1+c)}$ times fewer computation than \cite{armknecht2014outsourced};  Specifically, when $c=460$,  SO-PoR verification requires about $4.5$ times fewer computation than the verification in \cite{armknecht2014outsourced} needs\footnote{As shown in \cite{DBLP:conf/ccs/AtenieseBCHKPS07}, to ensure $99\%$ of file blocks is retrievable, it  suffices to set $c=460$.}. In SO-PoR, the cloud server needs to perform $Tz$ exponentiations to solve puzzles, however this is independent of the file size. The sever in \cite{Storage-Time} also performs $Tz$ modular multiplications and $3Tz$ modular exponentiations, which is  $3$ times higher than the  exponentiations done by the server in SO-PoR. The  protocols in \cite{armknecht2014outsourced,DBLP:conf/asiacrypt/ShachamW08} do not include the puzzle-solving procedure (and they do not offer all features that SO-PoR does).  Furthermore, the proving cost in SO-PoR is similar to that of in \cite{armknecht2014outsourced}, and is  much better than \cite{xu2016lightweight}, as the latter one requires both exponentiations and pairing operations while the prove algorithm in SO-PoR  does not involve any exponentiations. The  proving cost in \cite{Storage-Time} is the lowest, as it requires only invocations of a hash function.  Also, the store phase in SO-PoR has a much lower computation cost than the one in \cite{armknecht2014outsourced}. The reason is that the number of exponentiations required (in this phase) in SO-PoR is independent of file size and is only linear with the number of delegated verifications; however, the number of exponentiations in \cite{armknecht2014outsourced} is linear with the file size. For instance, when $||\vv{\bm{F}}||=1$-GB, the  total number of blocks is   $n=\frac{1-\text{GB}}{128-\text{bit}}=625\times 10^{\scriptscriptstyle 5}$. Since the number of exponentiations in \cite{armknecht2014outsourced} is linear with the number of blocks, i.e. $9n$, the total number of exponentiations imposed by the store algorithm is $5625\times 10^{\scriptscriptstyle 5}$ which is very high. This is the reason why in the experiment in \cite{armknecht2014outsourced} only a small file size $64$-MB, is used, that can be stored locally without the need to use  cloud storage, in the first place.  Now, we turn our attention to SO-PoR. Let the verification be done every month for a $10$-year period, in this case,  $z=120$.  So, the total number of exponentiations required by the store in SO-PoR is $121$. This means store phase in SO-PoR requires over $46\times 10^{\scriptscriptstyle 5}$ times  fewer exponentiations than the one in \cite{armknecht2014outsourced} needs. The store algorithm in \cite{xu2016lightweight} does not involve any exponentiations; however, its  number of modular additions and multiplication  is higher than the ones imposed by the SO-PoR's store. The  store cost in \cite{Storage-Time} is the lowest, as it requires only invocations of a hash function. Furthermore, the verification and prove cost of SO-PoR and privately verifiable PoR \cite{DBLP:conf/asiacrypt/ShachamW08} are identical. Thus, SO-PoR offers a very efficient verification algorithm that allows it to employ a smart contract to perform the verification, while its other computation costs are also reasonably low. But, this is not the case for the other protocols. 

%The verification in SO-PoR is  faster than the other two protocols; firstly, it requires no exponentiations, whereas \cite{xu2016lightweight} does, and secondly, it requires $\frac{9c+3}{2(1+c)}$ times fewer computation than \cite{armknecht2014outsourced}.  Specifically, when $c=460$,  SO-PoR verification requires about $4.5$ times fewer computations than the verification in \cite{armknecht2014outsourced} needs\footnote{As shown in \cite{DBLP:conf/ccs/AtenieseBCHKPS07}, to ensure $99\%$ of file blocks is retrievable, it would suffice to set $c=460$.}. In SO-PoR, the cloud   performs $Tz$ exponentiations to solve puzzles,  independent of the file size. The other two protocols do not include  a puzzle-solving procedure (and they do not offer all features that SO-PoR does). The proving cost in SO-PoR is similar to that of in \cite{armknecht2014outsourced}, and is  much better than \cite{xu2016lightweight}, as the latter one requires additional  exponentiations and pairing operations. The store phase in SO-PoR has a much lower computation cost than the one in \cite{armknecht2014outsourced}.  For instance, when $||\vv{\bm{F}}||=1$-GB, the  total number of blocks is:   $n=\frac{1-\text{GB}}{128-\text{bit}}=625\times 10^{\scriptscriptstyle 5}$. Since the number of exponentiations in \cite{armknecht2014outsourced} is linear with the number of blocks, i.e. $9n$, the total number of exponentiations imposed by the store algorithm is: $5625\times 10^{\scriptscriptstyle 5}$ which is very high. Now, we turn our attention to SO-PoR. Let the verification be done every month for  $10$ years period, in this case,  $z=120$.  So, the total number of exponentiations required by the store in SO-PoR is $121$. This means the store phase in SO-PoR needs over $46\times 10^{\scriptscriptstyle 5}$ times  fewer exponentiations than  \cite{armknecht2014outsourced} needs. The store algorithm in \cite{xu2016lightweight} does not involve any exponentiations. However, its  number of modular additions and multiplications  is higher than the ones imposed by SO-PoR' store algorithm. Also, the verification and prove costs in SO-PoR and in the very efficient privately verifiable PoR \cite{DBLP:conf/asiacrypt/ShachamW08} are identical.






\noindent\textbf{\textit{I/O Complexity}}. In SO-PoR and \cite{xu2016lightweight,armknecht2014outsourced}, for a server to generate a PoR, it only needs to access a constant number of file blocks. Therefore, their total I/O cost is $O(1)$. But,  in \cite{Storage-Time}  the server has to access a \emph{logarithmic number of file blocks} to generate a PoR, so its I/O cost is much higher than the rest. In particular, its total I/O cost is $O(\log n)$. Note that I/O cost plays a crucial role in the scalability of the server and its ability to serve multiple clients/queries degrades when the I/O cost is significantly high. 



 \noindent\textbf{\textit{Communication Complexity}}. A verifier-side bandwidth of SO-PoR (and \cite{xu2016lightweight,Storage-Time}) is much lower than \cite{armknecht2014outsourced}. For instance, when $||\vv{\bm{F}}||=1$-GB and $z=100$, a verifier in SO-PoR requires $62\times 10^{\scriptscriptstyle 6}$  fewer bits than the one in \cite{armknecht2014outsourced} does. A client in SO-PoR has a higher bandwidth than it would have in the rest of the protocols. But, this cost is one-off, at the setup phase.  The server-side bandwidth of SO-PoR is the lowest;  for instance (for the same parameters above) a server in SO-PoR requires $9\times 10^{\scriptscriptstyle4}$,  $7$, and $1729$ times fewer bits  than those required in \cite{armknecht2014outsourced}, \cite{xu2016lightweight} and \cite{Storage-Time} respectively.   Moreover, \cite{Storage-Time} has the worst proof size complexity, which is logarithmic to the file size; while the proof size complexity of the rest of the schemes  is constant.  Hence, SO-PoR's server-side bandwidth is significantly lower than the rest  while having constant proof size. 
