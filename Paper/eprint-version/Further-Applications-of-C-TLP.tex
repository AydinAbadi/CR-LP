% !TEX root =main.tex
\vspace{-6mm}
\section{C-TLP as Efficient Variant of VDF}\label{section::Variant-of-VDF}




There are cases where a client wants a server to learn distinct random challenges, at different points in time within a certain period, without the client's involvement in that period. Such challenges can let the server generate certain proofs that include but are not limited to the \emph{continuous availability of services}, such as data storage or secure hardware. The obvious candidates that can meet the above needs are VDF (if  public verifiability is desirable) and TDF (if   private verifiability suffices). PoSt protocols  in \cite{Storage-Time} are two examples of the above cases. We observed that, in these application areas, VDF/TDF can be replaced with our C-TLP to gain better efficiency. The idea is that the client computes random challenges, encodes them into C-TLP puzzles and sends them to the server who can eventually solve each puzzle, extract a subset of challenges and use them for the related proof scheme while letting the public efficiently verify the solutions' correctness. To illustrate the efficiency gain,  we compare C-TLP performance with the two current VDF functions \cite{Wesolowski19,BonehBBF18}. Table \ref{table::VDF-comparison} summarises the result. The cost analysis considers the generic setting where $z$ outputs are generated. Among several VDF schemes proposed in \cite{BonehBBF18}, we focus on the one that uses sequential squaring, as it is more efficient than the other schemes in \cite{BonehBBF18}.   As the table indicates, the overall cost of \cite{BonehBBF18} in each of the three phases is much higher than C-TLP and \cite{Wesolowski19}. Now, we compare the computation cost of C-TLP  with  \cite{Wesolowski19}.  At setup, a client  in C-TLP  performs at most $3z+1$ more exponentiations than it does in \cite{Wesolowski19}. But, at both prove and verify phases, C-TLP   outperforms \cite{BonehBBF18}, especially when they are in the same model. In particular,  at the prove phase, C-TLP, in both models,  requires $Tz$ fewer multiplications than  \cite{Wesolowski19} does. Also, in the same phase, it requires $3$ times fewer exponentiations than \cite{Wesolowski19}. In the verify phase,  when C-TLP is in the
standard model, it has a slightly lower cost than \cite{Wesolowski19} has in the random oracle model. However, when both of them in the random oracle model, C-TLP   has a much lower cost, as it requires no exponentiations whereas  \cite{Wesolowski19} needs $3z$ exponentiations.  Hence,  C-TLP   supports both standard and random oracle models and in both paradigms, it outperforms the fasted VDF, i.e. \cite{Wesolowski19}, designed in the random oracle model. Furthermore, the  proof size in C-TLP  is $3.2$ and $6.5$ times shorter than \cite{BonehBBF18} and  \cite{Wesolowski19} respectively, when they are in the same model. 




\input{table-VDF-cost.tex}

\input{PoSt-and-C-TLP}

%The use of C-TLP offers the following additional  benefits. 

%Recall that two protocols: basic PoSt and compact PoSt supporting proof of storage-time are proposed in \cite{Storage-Time}, where  basic PoSt uses VDF and is publicly verifiable while compact PoSt  utilises trapdoor delay function (TDF) and is privately verifiable. Also, recall that VDF/TDF is used to allow the server to derive multiple challenges at different points over a certain time period $T$. 
%
%We highlight that  both delay functions (VDF and TDF) impose the same computation overhead to the server, i.e. $3Tz$ modular exponentiations and $Tz$ modular multiplication if the fastest delay function is used \cite{Wesolowski19}. Moreover, in the basic PoSt, a verifier has to perform $3z$ exponentiations to verify $z$ outputs of VDF.  We observed that if the delays functions in these schemes are replaced with  our C-TLP, then both basic and compact   PoSt protocols' overall cost will be significantly reduced. The idea as follows. As in PoSt protocols, the client at the setup precomputes random challenges (and their PoR tags). But, it encodes challenges for $z-1$ PoR proofs  into puzzles using C-TLP. It sends the challenges for the first PoR proof, the puzzles and encoded file to the server. As in the PoSt protocols, the server generates the first PoR proof using the challenges sent to it in the plaintext. Nevertheless, for the server to find $j^{\scriptscriptstyle th}$ challenge to generate  $j^{\scriptscriptstyle th}$ PoR proof, it solves the related puzzle. Therefore, it does not need to  call VDF or TDF anymore. If the basic PoSt  is used, then the server sends C-TLP proofs that can be efficiently verified by anyone. On the other hand, if the compact PoSt is used, then the server does not need to send the C-TLP's proofs, as the client already knows the random challenges. With the above adjustment  the server's computation cost would be $\frac{1}{3}$ of the costs imposed by either of PoSt protocols. The reason is that C-TLP's solve puzzle algorithm only involves $Tz$ exponentiations as opposed to $3Tz$ exponentiations needed by VDF/TDF. The use of C-TLP offers two more benefits as well; namely,  there will be $3z$ further reduction in the number of exponentiations:  (a) at the verifier side, in the basic PoSt, as the server does not need to perform any exponentiation to check the correctness of C-TLP's output, whereas VDF's verify algorithm requires $3z$ exponentiations, and (b) at the client side, in the compact PoSt,  as the client does not need to evaluate TDF at the setup to precompute the challenges which in total involves $3z$ modular exponentiations over $\phi(N)$.


