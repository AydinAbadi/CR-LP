% !TEX root =main.tex
\subsection {Traditional PoR Model}\label{PoR-Model}

In this section, we restate a  definition of the traditional PoR scheme \cite{DBLP:conf/asiacrypt/ShachamW08}. In general, a PoR scheme considers the case where an honest client wants to store its file(s) on a  potentially malicious server, i.e active adversary. It is a challenge-response interactive protocol where the server proves to the client that its file is intact and retrievable. A PoR scheme comprises five algorithms: 

\begin{itemize}
\item[$\bullet$] $\mathtt{Setup}(1^{\scriptscriptstyle\lambda})\rightarrow sk$:  a probabilistic algorithm, run by a client, that takes an input a security:  $1^{\scriptscriptstyle\lambda}$ and outputs a secret key.

\

\item[$\bullet$] $\mathtt{Store}(sk,F)\rightarrow (F^{*}, \sigma)$: a probabilistic algorithm, run by a client, that takes an input the secret key: $sk$ and a file: $F$. It encodes $F$, denoted by $F^{*}$ as well as generating a set of  tags: $\sigma$, where $F^{*}$ and  $\sigma$ is stored on the server.

\

\item[$\bullet$] $\mathtt{GenChal}(|F^{*}|, 1^{\scriptscriptstyle\lambda})\rightarrow \vv{\bm{c}}$: a probabilistic algorithm, run by a client, that takes an input the encoded file size: $|F^{*}|$ and security:  $1^{\scriptscriptstyle\lambda}$. It outputs a set of pairs, $\ddot{c}_{\scriptscriptstyle j}:(x_{\scriptscriptstyle j},y_{\scriptscriptstyle j})$, where each pair includes a file block index: $x_{\scriptscriptstyle j}$ and coefficient: $y_{\scriptscriptstyle j}$, both of them are picked uniformly at random.

\

\item[$\bullet$] $\mathtt{Prove}(F^{*}, \sigma, \vv{\bm{c}})\rightarrow \pi$:  takes the encoded file: $F^{*}$, (a subset of) tags: $\sigma$, and a vector of unpredictable random challenges: $\vv{\bm{c}}$ as inputs and outputs a proof of the file retrievability. It is run by a server.

\

\item[$\bullet$] $\mathtt{Verify}(sk,\vv{\bm{c}}, \pi)\rightarrow\{0,1\}$: takes the secret key: $sk$,  vector of random challenges: $\vv{\bm{c}}$, and the proof $\pi$ as inputs. It outputs either $0$ if it rejects,  or $1$ if it accepts the proof. It is run by a client.

\end{itemize}


Informally, a PoR scheme has two main properties: correctness and soundness. The correctness requires that for any key, all files, the verification algorithm accepts a proof generated by an honest verifier. The soundness requires that if  a prover convinces the verifier (with a high probability) then the file is  stored by the prover; This is formalized via the notion of an extractor algorithm, that is able to extract the file in interaction with the adversary using a polynomial number of  rounds. In contrast to the definition in \cite{DBLP:conf/asiacrypt/ShachamW08} where $\mathtt{GenChal}(.)$ is implicit, in the above we have explicitly defined  it, as its modified version  plays an integral role in SO-PoR definition (and protocol). 
