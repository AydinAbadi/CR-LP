% !TEX root =main.tex


\section{SO-PoR Security Proof}\label{SO-PoR-Security-Proof}
In this section, we first restate the main security theorem of SO-PoR protocol (presented in Section \ref{SO-PoR-Protocol}) and then prove it.  


\


\noindent\textbf{Theorem \ref{PoR-main-theorem}.} \textit{SO-PoR protocol is secure (according to Definition \ref{SO-PoR-Security}) if the tags/MAC's are unforgeable, $\mathtt{PRF}(.)$ is a secure pseudorandom function, the blockchain is secure, C-TLP protocol is secure, and $\mathtt{H}( \mathcal {B}_{\scriptscriptstyle \gamma}||...||  \mathcal {B}_{\scriptscriptstyle \zeta})$ outputs an unpredictable random value (where $\zeta-\gamma$ is a security parameter).}


\begin{proof}[sketch]  In the following, we prove that SO-PoR protocol satisfies every  property that were defined in Appendix \ref{SO-PoR-Model}.   

\

\noindent\textbf{\textit{Verification correctness}} (according to Definition \ref{Verification-Correctness}). We first argue that the adversary who corrupts either $C\subseteq\{\mathcal{M}_{\scriptscriptstyle 1},...,\mathcal{M}_{\scriptscriptstyle\beta}\}$ or $C'\subseteq\{\mathcal{S},\mathcal{M}_{\scriptscriptstyle 1},...,\mathcal{M}_{\scriptscriptstyle\beta-1}\}$ with a high probability, cannot influence the output of $\mathtt{Verify}(.)$ performed by a smart contract in a blockchain; in other words, the verification correctness holds. In short, the verification correctness boils down to the security of the underlying blockchain. In the case where the adversary corrupts $C$ (when the server provides an accepting proof),  for the adversary to make the verification function output $0$, it has to: (a) either forge the server's signature, or (b)  fork the blockchain so the chain  comprising the accepting proof is discarded. In case (a),  if it manages to forge the signature, it can generate a transaction that includes   a rejecting proof where the transaction is signed on the server's behalf. In this case, it  can broadcast the transaction as soon as the transaction containing an accepting proof is broadcast,  to make the latter transaction stale. Nevertheless, the probability of such  an event is negligible, $\epsilon(\lambda')$, as long as the signature is secure. Moreover, due to the liveness property of blockchain, an honestly generated transaction will eventually appear on an honest miner's chain \cite{DBLP:conf/crypto/GarayKL17}. In case (b),  the adversary has to generate long enough (valid) chain that excludes the accepting proof, but this also has a negligible success probability, $\epsilon(\lambda')$, under the assumption that the hash power of the adversary is lower than those of  honest miners (i.e. under the honest majority assumption) and due to the liveness property. Now we turn our attention to the case where the adversary corrupts $C'$ (when the server provides a rejecting proof). In this case, for the adversary to make the verification function to output $1$, the honest miners must not validate the transaction that contains the proof. Nevertheless, as long as the blockchain is secure and  the computational advantage of skipping transaction validation is low, i.e. the validation imposes a low computation cost, the miners check   the transaction's validation \cite{LuuTKS15}. Also, as shown in \cite{LuuTKS15} when a transaction validation imposes a high computation cost, two generic techniques can be used to support exact or probabilistic correctness (of a smart contract function output). We conclude the correctness of $\mathtt{Verify}(.)$ output  is guaranteed with a high probability.

\

\noindent\textbf{\textit{$\epsilon$-extractable}} (according to Definition \ref{extractable}). In the following, we show that if   a proof produced by an adversary: $\mathcal{A}$ who corrupts $C'\subseteq\{\mathcal{S},\mathcal{M}_{\scriptscriptstyle 1},...,\mathcal{M}_{\scriptscriptstyle\beta-1}\}$ is accepted by $\mathtt{Verify(.)}$ with probability at least $\epsilon$, then the file can be extracted by a means of an extraction algorithm. As mentioned  before, $\mathtt{Verify(.)}$ can use both disposable and permanent tags, in the latter case $\mathtt{Verify(.)}$ is run by a smart contract, while in the former one the client runs it. For the sake of simplicity, we first consider the case where $C'=\mathcal{S}$. In this case, the extractability proof is similar to the one in \cite{DBLP:conf/asiacrypt/ShachamW08},  with a few differences, in SO-PoR: (a) the extractor can use both disposable tags and  permanent tags (when the former run out), (b) assumes  C-TLP protocol is secure, (c) assumes $\mathtt{H}( \mathcal {B}_{\scriptscriptstyle \gamma}||...||  \mathcal {B}_{\scriptscriptstyle \zeta})$ outputs a random value  even if $\beta$ miners try to influence its output. Note that in \cite{DBLP:conf/asiacrypt/ShachamW08} only the permanent tags are used, and since  the client generates the challenges and performs the verification, it does not use other primitives; hence, it does not require other security assumptions. As proven in  Theorems \ref{Solution-Privacy} and \ref{Solution-Validity}, C-TLP protocol is secure. Moreover, as  analysed and proven in \cite{DBLP:journals/iacr/AbadiCKZ19,armknecht2014outsourced}, an output of $\mathtt{H}( \mathcal {B}_{\scriptscriptstyle \gamma}||...||  \mathcal {B}_{\scriptscriptstyle \zeta})$ is random value even if some blocks are generated or selectively disseminated by malicious miners. We conclude that the extractor can extract the file when $C'=\mathcal{S}$, and  the extractor is interacting a  $\epsilon$-admissible prover. Now we move on to the case where $C'\subseteq\{\mathcal{S},\mathcal{M}_{\scriptscriptstyle 1},...,\mathcal{M}_{\scriptscriptstyle\beta-1}\}$. In this case, the proof (provided by $\mathcal{S}$) is rejecting but the corrupt miners may try to make $\mathtt{Verify}(.)$ output $1$. Note,  if they succeed to do so, then the file can be  extracted only by using the permanent tags but not the disposable ones. However, as shown above (i.e. due to the verification correctness), they have a negligible probability of success, when the blockchain is secure. 

\

\noindent\textbf{\textit{$\Upsilon$-real-time Detection}} (according to Definition \ref{real-time Detection}). In the following, we argue that after the server broadcasts a proof at a certain time, say $t$, to the network, the client can get a correct output of $\mathtt{Verify}(.)$ at most after time period $\Upsilon$, by a means of  reading the blockchain. The proof  is split into two parts: (a) correctness of $\mathtt{Verify}(.)$ output, and (b) the maximum delay on the client's view of the output. Since we have already shown above that (when $C$ or $C'$ is corrupt) the correctness of $\mathtt{Verify}(.)$  output is guaranteed,  we focus on the latter property, i.e. the delay. To describe the delay, we need to recall two blockchain notions: \emph{liveness} and \emph{slackness} \cite{DBLP:conf/crypto/GarayKL17,DBLP:conf/crypto/BadertscherMTZ17}. Informally, liveness states that an honestly generated transaction  will eventually be included more than $\mathtt{k}$ blocks deep in an honest party's  blockchain \cite{DBLP:conf/crypto/GarayKL17}. It is parameterised by wait time: $\mathtt{u}$ and depth: $\mathtt{k}$. We can fix the parameters as follows. We set $\mathtt{k}$ as the minimum depth of a block  considered as the blockchain's \emph{state}  (i.e. a part of the blockchain that remains unchanged with a high probability, e.g. $\mathtt{k}\geq 6$) and $\mathtt{u}$ the waiting time  that the transaction gets $\mathtt{k}$ blocks deep. As shown in \cite{DBLP:conf/crypto/BadertscherMTZ17}, there is a slackness on  honest parties' view of the blockchain.  In particular, there is no guarantee that at any given time, all honest miners have the same view of the blockchain, or even the  state. But, there is an upper-bound on the slackness,  denoted by $\mathtt{WindowSize}$, after which all honest parties would have the same view on a certain part of the blockchain state. This means when an honest party (e.g. the server) propagates its transaction (containing the proof) all honest parties will see it on their chain after at most: $\Upsilon=\mathtt{WindowSize}+\mathtt{u}$ time period. So when  the adversary corrupts $C$ or $C'$, but in the latter case the server constructs a valid transaction (regardless of the proof status) the client by reading the blockchain (i.e. probing the miners) can get a correct result after at most time period $\Upsilon$ when the server sends the proof. Also, when parties in $C'$ are corrupt and the transaction (containing the proof) is not valid,  as discussed above  (for verification correctness) the honest miners would detect the invalid transaction and do not include in the chain, therefore the output of $\mathtt{Verify(.)}$ would be the same as its default value: $0$; the same holds  when the server sends nothing to the network. This concludes the proof related to $\Upsilon$-real-time detection in SO-PoR protocol.


\

\noindent\textbf{\textit{Fair Payment}} (according to Definition \ref{Fair-Payment}).  The proof  takes into consideration that the correctness of an output of $\mathtt{Verify}(.)$  is guaranteed (as shown above). It boils down to the correctness of $\mathtt{Pay}(.)$ as it is interrelated to the output of $\mathtt{Verify}(.)$. In particular, for the adversary to make  inequality \ref{inequ::fair-payment} not  hold, it has to break $\mathtt{Pay}(.)$ correctness, e.g. pays the server despite the verification function outputs $0$. Therefore, it would suffice to show the adversary who corrupts $C$ or $C'$ cannot affect $\mathtt{Pay}(.)$ output's correctness. To do so, we can apply the same argument used to prove  the correctness of $\mathtt{Verify}(.)$ above, as the correctness of  $\mathtt{Pay}(.)$ relies on the security of the blockchain as well.  \hfill\(\Box\)
\end{proof}
