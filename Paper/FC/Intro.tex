% !TEX root =main.tex

\section{Introduction}


Time-lock puzzles are  interesting cryptographic primitives  that allow sending  information to the future. They enable  a party to lock a message such that,  no one else can unlock it until  a certain time has passed\footnote{ There exist protocols that use an assistance of a third party to support time-release of a secret.  This protocols' category is not our focus in this paper.}. They have a wide range of   applications, such as  e-voting \cite{ChenD12}, fair contract signing \cite{BonehN00},    and sealed-bid auctions \cite{Rivest:1996:TPT:888615}. Over the last two decades, a variety of time-lock puzzles have been proposed.  Nevertheless,  existing puzzle schemes  do not offer  any efficient remedy  for the multi-instance setting, where  a server is given multiple instances of a puzzle at once and it  should find one puzzle's solution after another.  It is a natural generalisation of the single puzzle setting. Application areas include, but not limited to:  (a) mass release of confidential documents  over time, (b) gradually revealing multiple secret keys, (c)    verifying continuous availability of cloud's services, e.g. data storage or secure hardware, or (d)  scheduled private payments, where  not only is every payment  made  after a certain  period, but also the payment details   remain confidential during the period. If  existing puzzle schemes are utilised directly in  the  multi-instance setting, then the server has to  deal with all puzzle instances, right after it receives them. This  results in a significant computation overhead and  requires a high level of parallelisation. %To date, there is no solution that mitigates  the aforementioned problem.
%It is a natural generalisation of the single puzzle setting.

In this paper, we propose  ``\emph{multi-instance time-luck puzzle}'', a primitive that allows composing a puzzle's instances, where given the composition, a server can deal with each instance sequentially. We formally define the primitive and  present an instantiation of it,  ``\emph{chained  time-lock puzzle}'' (C-TLP).  It makes black-box use of a standard time-lock puzzle scheme and is equipped  with a  \emph{lightweight} verification algorithm that allows anyone to check the correctness of a solution found by the server.    Its overall computation complexity of solving $z$ puzzles is  equivalent to that of solving only the last puzzle. The same procedure also imposes a  communication overhead linear with $z$, i.e. $O(z)$. C-TLP is the first time-lock puzzle scheme that offers all  the above features. Furthermore, we present  concrete applications of the primitive and demonstrate its use case in a blockchain-based solution. Specifically, we combine  the primitive's instantiation with a smart contract and apply the combination  to  ``outsourced proofs of  retrievability'' research line, and   propose ``\emph{smarter  outsourced proofs of retrievability}'' (SO-PoR) scheme which offers  a  combination of real-time detection and fair payment while  imposing very low overhead, that makes it particularly suitable for mission-critical data. SO-PoR verification and store phases impose $\frac{1}{4.5}$  and $\frac{1}{46\times 10^{\scriptscriptstyle 5}}$ of computation costs  imposed by the same phases in the fastest outsourced PoR. A server-side bandwidth of SO-PoR is much lower too;  for instance, for a $1$-GB file and $100$ verifications, a server in SO-PoR requires $9\times 10^{\scriptscriptstyle4}$ times fewer bits  than those required in the state of the art protocol.  Also, we show under certain circumstances  C-TLP can play the role of a ``verifiable delay function'' (VDF) but with much lower overhead, i.e. a prover's computation and communication costs will be reduced by factors of  $3$ and $6.5$ respectively.



%The key observation that led us to the design of C-TLP is that if existing time-lock puzzles are utilised naively in the multi-puzzle setting,  the process of solving  puzzles (in parallel) has many overlaps that yield a high computation overhead. By eliminating the overlaps, we can considerably lower the overall cost. To attain that goal, in C-TLP, a client creates puzzles \emph{outside-in} while  they can be solved only \emph{inside-out}. In the sense that the client iteratively creates a puzzle for the solution  revealed after the rest, and integrates the information needed for solving  it into the puzzle for the solution revealed earlier. For the server to find the puzzles' solution, it  begins to find a solution revealed earlier than the rest. The found solution gives it enough information to find the next puzzle's solution,  after a certain time. This process proceeds until the last solution is discovered.  Also, we use the following novel idea to let C-TLP attain public verifiability. The client, when creating a puzzle  for a solution, commits to the solution. It combines the solution with the commitment opening and creates a puzzle on the combination.  Then, it attaches the commitment to the puzzle. Later on, when the server solves the puzzle (unlike  traditional commitment schemes in which the committer is  the prover), it plays the role of prover and opens the related commitment to the public who  can efficiently verify the solution's correctness. While chaining different puzzles seems a relatively obvious approach to tackle the aforementioned issues, design a secure protocol that also can make black-box use of a standard time-lock puzzle, supports public verifiability, and has low costs is not trivial. 


%
%\noindent\textbf{C-TLP and Outsourced Proofs of Retrievability.} Proofs of retrievability (PoR) schemes provide a strong guarantee to a client  that its data stored on a (potentially malicious) cloud  server  can be fully accessed  when required. Recently, researchers  developed \emph{outsourced} PoR schemes that  enable clients to  delegate the verification phase to a potentially malicious third-party auditor. Nevertheless, the existing outsourced PoRs  have a set of shortcomings, e.g. lack of real-time detection, lack of fair payment mechanism, or imposing  high costs.   In this paper, we present  \emph{smarter  outsourced proofs of retrievability} (SO-PoR) scheme,  the first efficient outsourced   PoR  that addresses the above issues. It allows a client to delegated PoR verification, meanwhile efficiently detecting the  server misbehavior in (almost) \emph{real-time} without the need to re-execute the verification itself. Supporting real-time detection makes SO-PoR  particularly suitable for mission-critical data.  It supports a \emph{fair payment}, meaning that the server gets paid only if it provides accepting proofs. SO-PoR outperforms the state of the art.  In particular, SO-PoR verification and store phases impose $\frac{1}{4.5}$  and $\frac{1}{46\times 10^{\scriptscriptstyle 5}}$ of computation costs  imposed by the same phases in the fastest outsourced PoR  (when the number of delegated verification is 100 and file size is $1$-GB). Also, SO-PoR has significantly lower communication cost than the fastest outsourced PoR.  The computation cost of verification and prove   in SO-PoR is identical to the costs in  the well-known \emph{privately} verifiable PoR scheme, while  both  have $O(1)$ proof size complexity.  In this scheme, C-TLP plays a focal role, and makes it  feasible  for SO-PoR to support efficient outsourced PoR verification and offer   the aforementioned features.  SO-PoR  leverages C-TLP, as an efficient key-escrow, to periodically disseminate PoR verification keys to a smart contract. The contract  performs the verification, on the client's behalf,  using lightweight message authenticated code (MAC). State it differently, in SO-PoR a smart contract performs PoR verifications using low-cost MAC; since MACs are only privately verifiable and smart contracts do not maintain a private state, SO-PoR also leverages C-TLP   to efficiently compensate for the smart contract's lack of privacy.
%
%
%
%\noindent\textbf{C-TLP and Verifiable Delay Function.} A verifiable delay function (VDF) allows a prover to provide publicly verifiable proofs proving it performed certain numbers of sequential
%computation. Recently, VDF's have drawn a lot of attention due to a wide range of applications they offer. A newly explored application of VDF's is in the settings where \emph{continuous availability of cloud's services} (e.g. data storage \cite{Storage-Time}) is desired. We show in such cases, VDF's can be replaced with C-TLP to gain better efficiency. As a result, the cloud's computation and communication overheads will be reduced by factors of  $3$ and $6.5$ respectively. 
%



\noindent\textbf{Summary of Our Contributions.} We (a) put forth the notion of multi-instance  time-lock puzzle,  formally define it, and identify its concrete applications,
(b) present a candidate construction, C-TLP,  the first multi-instance time-lock puzzle that is  built on a standard time-lock puzzle,  supports public verifiability, and  has low costs,   (c)  propose   the first  outsourced PoR that can offer  real-time detection and  fair payment while maintaining low costs, and (d) show in certain cases, a VDF can be replaced with C-TLP to gain better efficiency.



\vspace{-3mm}


